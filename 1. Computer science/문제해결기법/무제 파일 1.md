
# 세그먼트 트리 (최솟값)

``` java
import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.FileReader;

import java.io.FileWriter;

import java.util.Arrays;

import java.util.stream.Stream;

  

public class rmq {

  

    static int miss = 10000000;

  

    public static void changing(int[] result, int start, int end, int idx, int change, int node) {

        // 범위 밖에 있는경우

        if (idx < start || end < idx) {

            return;

        }

        if (start == end) {

            result[node] = change;

  

            for (int i = node / 2; i >= 1; i = i / 2) {

                result[i] = Math.min(result[i * 2], result[i * 2 + 1]);

            }

            // 여기수정

            return;

        }

        // 중간값 설정

        int mid = (start + end) / 2;

  

        changing(result, start, mid, idx, change, node * 2);

        changing(result, mid + 1, end, idx, change, node * 2 + 1);

    }

  

    // start: 시작, end 끝 , left 구하고자하는 왼쪽, right 구하고자하는 오른쪽

    public static int findMinimum(int[] result, int start, int end, int left, int right, int node) {

        if (end < left || start > right) {

            return miss;

        }

        // 찾으려는 범위에 구간정보가 포함될때

        if (left <= start && end <= right) {

            return result[node];

        }

  

        int middle = (start + end) / 2;

        // 찾아야하는 구간이 노드구간에 포함되거나 부분적으로 겹치는경우

  

        int L = findMinimum(result, start, middle, left, right, node * 2);

        int R = findMinimum(result, middle + 1, end, left, right, node * 2 + 1);

  

        return Math.min(L, R);

  

    }

  

    public static int init(int[] result, int[] arr, int start, int end, int node) {

        // 리프노트드에는 그자체의 그냥 단 값을 저장

        if (start == end) {

            result[node] = arr[start];

            return result[node];

        }

        int middle = (start + end) / 2;

        // 재귀적으로 두 부분으로 나눈 뒤에 그중 최소값을 부모노드에 저장

  

        return result[node] = Math.min(init(result, arr, start, middle, node * 2),

                init(result, arr, middle + 1, end, node * 2 + 1));

    }

  

    public static void main(String agrs[]) throws Exception {

  

        try {

            FileReader fileReader = new FileReader("rmq.inp");

            BufferedReader bufferedReader = new BufferedReader(fileReader);

            FileWriter fileWriter = new FileWriter("rmq.out");

            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

  

            StringBuilder sb = new StringBuilder();

  

            int n = Integer.parseInt(bufferedReader.readLine());

  

            int[] result = new int[(n * 4) + 1];

            String str = bufferedReader.readLine();

            int[] arr = Stream.of(str.split(" ")).mapToInt(Integer::parseInt).toArray();

            int sum = 0;

            init(result, arr, 0, n - 1, 1);

  

            while (true) {

                String[] line = bufferedReader.readLine().split(" ");

                if (line[0].equals("c")) {

                    int idx = Integer.parseInt(line[1]);

                    int change = Integer.parseInt(line[2]);

                    arr[idx] = change;

  

                    changing(result, 0, arr.length - 1, idx, change, 1);

                } else if (line[0].equals("q")) {

                    int min_value = 0;

                    int min_idx = 0;

  

                    min_value = findMinimum(result, 0, arr.length - 1, Integer.parseInt(line[1]),

                            Integer.parseInt(line[2]),

                            1);

  

                    for (int i = 0; i < arr.length; i++) {

                        if (arr[i] == min_value) {

                            min_idx = i;

                            break;

                        }

                    }

                    sum += min_idx;

                } else {

                    break;

                }

            }

            sb.append(sum);

            bufferedWriter.write(sb.toString().trim());

            bufferedWriter.flush();

  

        } catch (Exception e) {

            System.out.println(e);

        }

    }

}
```



``` java
import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.FileReader;

import java.io.FileWriter;

import java.util.stream.Stream;

  

public class rmq {

  

    static int miss = -1;

  

    public static void changing(int[] result, int[] arr, int start, int end, int idx, int change, int node) {

        if (idx < start || end < idx) {

            return;

        }

  

        if (start == end) {

            result[node] = idx;

  

            for (int i = node / 2; i >= 1; i = i / 2) {

                int L = result[i * 2];

                int R = result[i * 2 + 1];

  

                if (arr[L] > arr[R]) {

                    result[i] = R;

                } else if (arr[L] < arr[R]) {

                    result[i] = L;

                } else {

                    result[i] = L;

                }

            }

            return;

        }

  

        int mid = (start + end) / 2;

  

        changing(result, arr, start, mid, idx, change, node * 2);

        changing(result, arr, mid + 1, end, idx, change, node * 2 + 1);

    }

  

    public static int findMinimum(int[] result, int[] arr, int start, int end, int left, int right, int node) {

        if (end < left || start > right) {

            return miss;

        }

  

        if (left <= start && end <= right) {

            return result[node];

        }

  

        int middle = (start + end) / 2;

  

        int L = findMinimum(result, arr, start, middle, left, right, node * 2);

        int R = findMinimum(result, arr, middle + 1, end, left, right, node * 2 + 1);

  

        if (L == miss) {

            return R;

        } else if (R == miss) {

            return L;

        } else {

            if (arr[L] < arr[R]) {

                return L;

            } else if (arr[L] > arr[R]) {

                return R;

            } else {

                return L;

            }

        }

  

    }

  

    public static int init(int[] result, int[] arr, int start, int end, int node) {

  

        if (start == end) {

            result[node] = start;

            return result[node];

        }

        int middle = (start + end) / 2;

  

        int L = arr[init(result, arr, start, middle, node * 2)];

        int R = arr[init(result, arr, middle + 1, end, node * 2 + 1)];

  

        if (L > R) {

            return result[node] = result[node * 2 + 1];

        } else if (L < R) {

            return result[node] = result[node * 2];

        } else {

            return result[node] = result[node * 2];

        }

  

    }

  

    public static void main(String agrs[]) throws Exception {

  

        try {

            FileReader fileReader = new FileReader("rmq.inp");

            BufferedReader bufferedReader = new BufferedReader(fileReader);

            FileWriter fileWriter = new FileWriter("rmq.out");

            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

  

            StringBuilder sb = new StringBuilder();

  

            int n = Integer.parseInt(bufferedReader.readLine());

  

            int[] result = new int[(n * 4) + 1];

            String str = bufferedReader.readLine();

            int[] arr = Stream.of(str.split(" ")).mapToInt(Integer::parseInt).toArray();

            int sum = 0;

            init(result, arr, 0, n - 1, 1);

  

            while (true) {

                String[] line = bufferedReader.readLine().split(" ");

                if (line[0].equals("c")) {

                    int idx = Integer.parseInt(line[1]);

                    int change = Integer.parseInt(line[2]);

                    arr[idx] = change;

  

                    changing(result, arr, 0, arr.length - 1, idx, change, 1);

                } else if (line[0].equals("q")) {

                    int min_value = 0;

  

                    min_value = findMinimum(result, arr, 0, arr.length - 1, Integer.parseInt(line[1]),

                            Integer.parseInt(line[2]),

                            1);

  

                    sum += min_value;

                } else if (line[0].equals("s")) {

                    break;

                }

            }

            sb.append(sum % 100000);

            bufferedWriter.write(sb.toString().trim());

            bufferedWriter.flush();

  

        } catch (Exception e) {

  

        }

    }

}
```