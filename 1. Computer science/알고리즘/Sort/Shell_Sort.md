---
tags:
  - ComputerScience
  - Sort
---

https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html
# Shell sort란 무엇인가

- Donald L. Shell’이라는 사람이 제안한 방법으로, <mark style="background: #FF5582A6;">삽입정렬을 보완</mark>한 알고리즘이다
- 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안
	- 삽입 정렬의 최대 문제점: 요소들이 삽입될 때, 이웃한 위치로만 이동
	- 즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있다.
	- 삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않는다.



## 쉘 정렬 아이디어

- insertion sort를 이용하여 배열 뒷부분의 작은 숫자를 앞부분으로 빠르게 이동시키고
- 동시에 앞부분의 큰 숫자는 뒷부분으로 빠르게 이동시킴

![[Pasted image 20231115163414.png]]

- 이후 각 그룹별로 삽입정렬
-  간격을 줄여가면서 간격 1까지 하면 정렬완료

#### 간격을 마지막엔 반드시 1로 해야함
- 왜냐하면 다른 그룹에 속해 서로 비교되지않은 숫자가 있을 수 있기 때문
-  모든원소를 1개의 그룹으로 여기는 것이고 이는 ,삽입정렬 그 자체

## Time Complexity

- 사용하는 간격에 따라 분석해야 함
- 최악의 경우 : 히바드의 간격 O(^1.5)
- 아직 풀리지 않은문제다
-  가장좋은 간격을 알아내야하는것이 선행되어야 하기 때문

# 쉘 정렬의 특성
- 입력의 크기가 매우 크지 않은 경우에 매우 좋은 성능을 보임
- 임베디드 시스템에서 주로 사용 
  - 간격에따른 그룹별 정렬 방식이 H/W로 정렬알고리즘을 구현하는 데 매우 적합함

# 실습코드

``` python
A=[30,60,90,10,40,80,40,20,10,60,50,30,40,90,80]
n=len(A)

for h in range(5,0,-1): # h == each_gap
    for i in range(h, n):
        CurrentElement=A[i]
        j=i
        while j>=h and A[j-h]>CurrentElement:
            A[j]=A[j-h]
            j=j-h

        A[j]=CurrentElement

print(A)
```